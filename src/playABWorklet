  playABWorklet(delay, timeA, timeB, recording = false, 
       offline = false, exporter='none'){

    console.log('playAB', 'delay, timeA, timeB, offline, recording, exporter = ', 
    delay, timeA, timeB, offline, recording, exporter);

    if (this.state.isPlaying) return;
    if (this.audioCtx.state === 'suspended' ) this.audioCtx.resume();

    this.setState({isPlaying : true});
    this.shifter = null;

    const sampleRate = this.inputAudio[0].data.sampleRate;
    const channels = this.inputAudio[0].data.numberOfChannels;
    const nInputFrames = (timeB - timeA)*sampleRate;
    const nOutputFrames = Math.max(nInputFrames, 
                      nInputFrames/this.state.playSpeed);
  
    let context;
    if (offline) {
      context = new window.OfflineAudioContext (
        channels, // typically 2
        nOutputFrames + 1.0*sampleRate, // length in frames (add 1 sec)
        sampleRate
       ); // Offline
      if (window.OfflineAudioContext.suspend) context.suspend();

    } else context = this.audioCtx;

    const shifter = new MyPitchShifter(
       context, nInputFrames, 4096, recording, this.state.bypass);

    if (!offline) this.shifter = shifter; // to allow change while playing

    shifter.tempo = this.state.playSpeed;

    shifter.pitch = Math.pow(2.0,this.state.playPitch/12.0);

    if (!offline) {
      const masterGainNode = context.createGain();
      masterGainNode.gain.value = this.state.masterGain/100.0;
      this.masterGainNode = masterGainNode;
    }

    for (let i=0; i < this.inputAudio.length; i++){
      const source = context.createBufferSource();
      source.buffer = this.inputAudio[i].data;
        this.inputAudio[i].source = source;
      const gainNode = context.createGain();
        gainNode.gain.value = this.state.gains[i]/100.0;
        this.inputAudio[i].gainNode = gainNode;
      source.connect(gainNode);
      gainNode.connect(shifter.node);
    }

    if (offline)   
      shifter.node.connect(context.destination);
    else {
      const masterGainNode = context.createGain();
      this.masterGainNode = masterGainNode;
      masterGainNode.gain.value = this.state.masterGain/100.0;
      shifter.node.connect(masterGainNode);
      masterGainNode.connect(context.destination);
    }

    const startedAt = context.currentTime + delay;
    for (let i=0; i < this.inputAudio.length; i++){
      this.inputAudio[i].source.start(startedAt, timeA, timeB - timeA);
    }

    if (offline) context.startRendering();

    this.setState({playingAt: timeA});

    if (offline)
      shifter.onUpdateInterval = 10.0;
    else shifter.onUpdateInterval = 1.0;

    shifter.onUpdate = function() {
      this.setState({playingAt: timeA + shifter.playingAt});
    }.bind(this);

    shifter.onEnd = function () { // callback from MyPitchShifter
      console.log('MyPitchShifter.onEnd');

      for (let i=0; i < this.inputAudio.length; i++)
            this.inputAudio[i].gainNode.disconnect();

      if (exporter === 'exportFile' ) {
         // console.log ('Call exportToFile');
         shifter.exportToFile('mix_' + Date.now() + '.wav');
      } else if (exporter === 'playMix'){
         console.log ('playing mix');
         const context = this.audioCtx;
         const source = context.createBufferSource();
           this.mixedSource = source;
           source.buffer = shifter.recordedBuffer;
         const masterGainNode = context.createGain();
           this.masterGainNode = masterGainNode;
           masterGainNode.gain.value = 1.0;
         source.connect(this.masterGainNode);
         masterGainNode.connect(context.destination);
         source.start();

         source.onended = function(e) {
           this.mixedSource = null;
           this.setState({isPlaying: false});
         }.bind(this)

      }
 
      this.shifter = null;

      this.setState({
        playingAt: this.state.timeA, // maybe modified during playback
        isPlaying: false
      });

      if (!offline && this.state.loop) 
             this.playAB(2, this.state.timeA, this.state.timeB);
        else this.setState({ startButtonStr: 'Pause' });

    }.bind(this);

    // if (!offline) /* When stop button is pressed */
      this.inputAudio[0].source.onended = function (e) { 
        shifter.stop(); 
        this.setState({isPlaying: false, startButtonStr: 'Play'});
      }.bind(this)

    if (offline)
      context.oncomplete = function(e) {
        console.log( 
         'Offline render complete (data is useless though) length = ',
          e.renderedBuffer.length);
      }

  } // END playABWorklet
